simpleaf workflow run
=====================

The ``simpleaf workflowr run`` command is designed to run potentially complex single-cell data processing workflows using an instantiated simpleaf workflow template. Please check our tutorial on `running an workflow from an published template <https://combine-lab.github.io/alevin-fry-tutorials/2023/running-simpleaf-workflow/>`_ and `developing custom template from scratch <https://combine-lab.github.io/alevin-fry-tutorials/2023/build-simpleaf-workflow/>`_

``simpleaf workflow run`` exposes two required flags: 

* ``--template`` takes the path to an instantiated simpleaf workflow template. One can develop their own templates or grab published templates from the `protocol estuary <hhttps://github.com/COMBINE-lab/protocol-estuary>`_ GitHub repository using the API we provided, the ``simpleaf workflow get`` command and fill in required information. 
* ``--output`` takes the path to the output directory for writing the log files, and, if programmed in a specific template, the results generated by invoking workflow commands.

When calling ``simpleaf workflow run`` using an instantiated template, _simpleaf_ will first convert the  template, which is a `Jsonnet <https://jsonnet.org/>`_ program, into a workflow manifest in JSON format. Whereas the workflow template provides a "template" for the workflow and functions to handle features like basic logic, the resulting workflow manifest is a simple imperative description of the commands to be executed. To provide the greatest flexibility, the only requirement we set for a simpleaf workflow template is that in the workflow manifest its results, the fields representing a command record, either a simpleaf or an external shell command, follow the format described in section `Valid simpleaf workflow manifest format`_. 

Then, ``simpleaf workflow run`` will traverse the workflow manifest to collect the simpleaf and external shell command records and put them into an execution queue, ordered by their ``Step`` number.

``simpleaf workflow run`` also exposes multiple flags for controlling the execution flow when invoking the commands. If none of the flags is set, _simpleaf_ will invoke all commands in the execution queue. 

* If setting the ``--no-execution`` flag, _simpleaf_ will parse the file passed to the ``--template``, write the log files, and return without invoking any command.
* If setting the ``--start-at`` flag with an ``Step`` number, _simpleaf_ will ignore all previous steps (commands) and begin the invocation from the commands in the execution queue whose `Step` is equal or next to that specific starting ``Step``.
* If setting the ``--resume`` flag, _simpleaf_ will try to find the log file from a previous run in the provided output folder to decide which ``Step`` to begin with.
* If setting the ``--skip-step`` flag with a set of comma-separated ``Step`` numbers, _simpleaf_ will ignore the commands whose ``Step`` is in those numbers. 

Workflow Output
^^^^^^^^^^^^^^^

``simpleaf workflow run`` writes two log files to the output directory passed to ``--output``:

* ``simpleaf_workflow_log.json``: This file records the meta and logging information of the workflow execution. For example, the runtime of each executed command and the ``Step`` of the start and terminating command. If ``--resume`` is set, _simpleaf_ will try to find this file in the provided output directory to decide which step(command) to start.
* ``workflow_execution_log.json``: This file is a modified version of the workflow manifest JSON discussed above. The only modification is that in this file, the ``Active`` of the successfully invoked commands (return code 0) becomes `false`.  

The results generated by successfully invoked commands might or might not be exported to the output directory specified in ``--output``, as the output directory of each invoked command is defined in the workflow template passed to ``--config-file``, rather than by ``simpleaf workflow``. Most of the workflow templates developed by the simpleaf team will store all commands' results to the output directory passed to ``--output`` if no output directory is provided in the template.

Full Usage
^^^^^^^^^^

The relevant options (which you can obtain by running ``simpleaf workflow run -h``) are:

.. code-block:: console

    Parse an instantiated workflow template and execute the corresponding commands

    Usage: simpleaf workflow run [OPTIONS] --template <TEMPLATE> --output <OUTPUT>

    Options:
    -t, --template <TEMPLATE>    path to an instantiated simpleaf workflow template
    -o, --output <OUTPUT>        output directory for log files and the workflow outputs that have no explicit output directory
    -l, --lib-paths <LIB_PATHS>  comma separated library search paths when processing the (custom) workflow configuration file. (right-most wins)
    -h, --help                   Print help
    -V, --version                Print version

    Control Flow:
    -n, --no-execution           return after converting the config file to JSON foramt without executing the commands
    -s, --start-at <START_AT>    Start the execution from a specific Step. All previous steps will be ignored [default: 1]
    -r, --resume                 resume execution from the termination step of a previous run. To use this flag, the output directory must contains the JSON file generated from a previous run
        --skip-step <SKIP_STEP>  comma separated integers indicating which steps (commands) will be skipped during the execution



The procedure of parsing a simpleaf workflow template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In ``simpleaf workflow``, we use the `Jrsonnet <https://github.com/CertainLach/jrsonnet>`_, a rust implementation of Jsonnet, to parse the instantiated workflow template passed. Any valid `Jsonnet <https://jsonnet.org/>`_  program and JSON file is a valid simpleaf workflow template as long as it can produce a valid workflow manifest.
When calling Jrsonnet, ``simpleaf workflow`` automatically passes the following arguments in addition to the provided template. This also means that any custom configuration program can access the ``output`` and ``utils`` variables in the Jsonnet program using ``std.extVar("output")`` and ``std.extVar("utils")``. Note that the path to the parent directory of the file passed to ``--config-file`` is an additional library search directory in Jrsonnet by default.

1) The output directory passed to ``--output`` as the external variable ``output``.
2) The workflow utility library from the protocol estuary as the external variable ``utils``.
3) The path to the ``utils`` folder in the protocol estuary in ``ALEVIN_FRY_HOME`` as an additional library search directory.
4) The paths passed to the ``--lib-path`` flag, if any, as additional library search directories.

Valid simpleaf workflow manifest format
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Although any Jsonnet program or JSON file is a valid input for ``simpleaf workflow``, it doesn't means they all can be converted to a valid simpleaf workflow manifest JSON. To provide the greatest flexibility, we only set the requirements for the fields representing a command record, either a simpleaf command or an external command, in the simpleaf workflow manifest JSON file (not the configuration program). 

* To ease the later parsing process, all fields that represents a  command argument must be provided as strings, i.e., wrapped by quotes (``"value"``), even for integers like the number of threads (for example, ``{“--threads”: "16"}`` for simpleaf commands).
* A command record field must contain a ``Step`` and a ``Program Name`` sub-field, where the ``Step`` field represents which step, **using an unassigned integer**, this command constitutes in the workflow. This is the only valid integer field being parsed in the workflow manifest. The ``Program Name`` field represents a valid program in the user's execution environment **as a string**. 
    * For a simpleaf command, the correct ``Program Name`` is the name of the simpleaf command as a string. For example, for ``simpleaf index``, it is ``"simpleaf index"`` and for ``simpleaf quant``, it is ``"simpleaf quant"``.
    * For an external command such as ``awk``, if its binary is in the user's ``PATH`` environmental variable, it can just be ``"awk"``; if not, it must contain a valid path to its binary, for example, ``"/usr/bin/awk"``.
* A command record can also have a `"Active"` boolean field representing if this command is active. Simpleaf will ignore (neither parse nor invoke) all commands that are inactive (`{"Active": false}`). For command records missing this field, simpleaf will regard them as active commands.
* If a field records a simpleaf command, the name of its sub-fields, except ``Step`` and ``Program Name``, must be valid simpleaf flags (for example, options like ``--fasta``, or ``-f`` for short, for ``simpleaf index`` and ``--unfiltered-pl`` (or ``-u``) for ``simpleaf quant``). Those option names (sub-field names), together with their values, if any, will be used to call the corresponding simpleaf program. Sub-fields not named by a valid simpleaf flag will trigger an error.
* If a field records an external shell command, it must contain a valid ``Step`` and ``Program Name`` sub-field as described above. In contrast to simpleaf command records, all arguments of an external shell command must be provided in an array, in order, with the name ``"Argument"``. ``Simpleaf workflow`` will parse the entries in the array to build the actual command in order. For example, to tell ``simpleaf workflow`` to invoke the shell command  ``ls -l -h .`` at step 7, one needs to use the following JSON record:

  .. code-block:: console

    {
        "Step": 7,
        "Program Name": "ls",
        "Active": true,
        "Arguments": ["-l", "-h", "."]
    }

